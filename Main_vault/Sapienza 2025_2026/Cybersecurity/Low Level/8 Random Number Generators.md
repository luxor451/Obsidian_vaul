**Tags:** #Cybersecurity #LowLevel #Cryptography #RNG #PRNG #CSPRNG #Math

---

## 1. Introduction to Randomness

**"The generation of random numbers is too important to be left to chance."** — Robert Coveyou

### Importance
Random numbers are fundamental to cryptographic security.
* **Session Keys:** Generating ephemeral keys for secure communication.
* **Key Generation:** Creating static private/public key pairs.
* **Nonces:** Unique values to prevent replay attacks.
* **Salts:** Random data to protect passwords.

**Security Implication:**
If an adversary knows the sequence of past keys, the probability of predicting the next key must be **negligible**. A good random number generator is computationally expensive but necessary.

---

## 2. Types of Generators

There are two principal methods for generating random numbers:

### 1. True Random Number Generators (TRNG / RNG)
* **Mechanism:** Measures a physical phenomenon expected to be random.
* **Sources:**
    * Thermal noise.
    * Radioactive decay.
    * Air turbulence (e.g., hard drive head movements).
    * User input (mouse movements, keystrokes).
* **Properties:** Non-deterministic.
* **Issue:** Physical measurements can be biased; post-processing is required to "whiten" (remove bias) the output.

### 2. Pseudo-Random Number Generators (PRNG)
* **Mechanism:** Deterministic algorithms that produce long sequences of "apparently" random values based on an initial value.
* **Seed:** The initial secret value that determines the entire sequence.
* **Properties:**
    * **Deterministic:** Same seed $\rightarrow$ Same sequence.
    * **Periodic:** The sequence eventually repeats (though the period should be massive).

---

## 3. Statistical Tests for Randomness

To determine if a generator is good, we apply statistical tests (e.g., NIST SP 800-22).

### Hypothesis Testing
* **Null Hypothesis ($H_0$):** The sequence is random.
* **Alternative Hypothesis ($H_a$):** The sequence is not random.
* **Decision:** We accept the sequence if the p-value indicates that the data is consistent with $H_0$.

### Common Tests

#### A. Frequency Test (Monobit Test)
Checks if the number of 0s and 1s is approximately equal.
* **Input:** A sequence of $n$ bits.
* **Transformation:** Convert $0 \rightarrow -1$ and $1 \rightarrow +1$.
* **Statistic:**
$$
X_n = \sum_{i=1}^{n} (2s_i - 1)
$$

* **Test Statistic:**
$$
S_{obs} = \frac{|X_n|}{\sqrt{n}}
$$

* **Decision:** If $S_{obs}$ is large (exceeds a critical value), reject randomness.

#### B. Runs Test
Checks for clusters of identical bits (e.g., `000` or `1111`).
* **Run:** A maximal sequence of consecutive identical bits.
* **Logic:** A random sequence should not have excessively long runs or too many/few runs compared to the expected distribution.

#### C. Maurer’s Universal Statistical Test
Checks if the sequence can be significantly compressed.
* **Principle:** If a sequence can be compressed (has low entropy), it has patterns and is therefore **predictable** (not random).
* **Mechanism:** Relies on the distance between occurrences of patterns.

---

## 4. Cryptographically Secure PRNG (CSPRNG)

A standard PRNG (like `rand()` in C) is designed for speed and statistical randomness, not security. A **CSPRNG** must meet stricter requirements.

### Requirements
1.  **Statistical Randomness:** Must pass all standard statistical tests (frequency, runs, etc.).
2.  **Next-Bit Test:**
    Given a sequence of $k$ bits generated by the PRNG, there is no polynomial-time algorithm that can predict the $(k+1)$-th bit with probability significantly greater than $1/2$.
3.  **State Compromise Resistance:**
    * **Forward Secrecy:** If the internal state is compromised, the attacker cannot reconstruct *previous* random numbers.
    * **Backward Secrecy (Future Secrecy):** If the state is compromised, the attacker cannot predict *future* numbers (provided the PRNG is reseeded with new entropy).

---

## 5. Specific PRNG Algorithms

### 1. ANSI X9.31 RNG (Deprecated)
Historically used in banking/finance, now deprecated.
* **Components:**
    * AES or 3DES block cipher ($E_K$).
    * Date/Time vector ($DT$).
    * Secret Seed ($V$).
* **Operation:**
$$
\begin{aligned}
I &= E_K(DT) \\
R_i &= E_K(I \oplus V_{i-1}) \quad \leftarrow \text{Output Random Block} \\
V_i &= E_K(I \oplus R_i) \quad \leftarrow \text{Update Internal State}
\end{aligned}
$$

### 2. Blum Blum Shub (BBS)
A cryptographically provable PRNG based on the hardness of integer factorization.
* **Setup:**
    1.  Choose two large primes $p, q$ such that $p \equiv q \equiv 3 \pmod 4$.
    2.  Compute $n = p \cdot q$.
    3.  Choose a random seed $s$ such that $\gcd(s, n) = 1$.
* **Generation:**
    * Initialize: $X_0 = s^2 \mod n$.
    * Loop for each bit $B_i$:
$$
\begin{aligned}
X_i &= (X_{i-1})^2 \mod n \\
B_i &= X_i \mod 2 \quad (\text{Least Significant Bit})
\end{aligned}
$$

* **Security:** Predicting the output is equivalent to solving the **Quadratic Residuosity Problem** (which is hard if factoring $n$ is hard).
* **Performance:** Very slow; used for key generation, not stream encryption.

### 3. CTR_DRBG (NIST SP 800-90A)
One of the current standards for deterministic random bit generation.
* **Mechanism:** Uses a block cipher (like AES-256) in **Counter (CTR) Mode**.
* **State:** Key $K$, Counter $V$.
* **Generate:**
    1.  Increment Counter: $V \leftarrow V + 1$.
    2.  Encrypt Counter: $Block = E_K(V)$.
    3.  Output block.
* **Security:** Relies on the security of the underlying block cipher (AES). If AES is indistinguishable from a random permutation, the output is secure.

---

## 6. Linear Congruential Generator (LCG) - *Avoid for Crypto*
The standard PRNG used in many libraries (e.g., standard Java/C++ `random`).
* **Formula:**
$$
X_{n+1} = (aX_n + c) \mod m
$$

* **Flaw:** It is linear and predictable. Observing a few outputs allows solving the linear equations to find $a, c, m$ and predict all future values.
* **Verdict:** **Never use for cryptography.**

---

## 7. Entropy and /dev/random
Operating systems gather "entropy" (randomness) from hardware events to seed PRNGs.

### Linux Implementation
* **Entropy Pool:** A buffer storing random bits collected from drivers (keyboard, disk, mouse).
* **Interfaces:**
    1.  `/dev/random`: Returns bytes from the pool. **Blocks** if the pool is empty (waits for more environmental noise). Highest quality.
    2.  `/dev/urandom`: Returns bytes from a PRNG seeded by the pool. **Non-blocking**. Preferred for most cryptographic applications today (modern CSPRNGs don't need constant reseeding once initialized).