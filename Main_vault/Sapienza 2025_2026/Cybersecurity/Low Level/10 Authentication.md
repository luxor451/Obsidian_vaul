**Tags:** #Cybersecurity #LowLevel #Authentication #Protocols #NeedhamSchroeder #KDC #Biometrics

---

## 1. Introduction to Authentication

### Definition
**Authentication** is the process of reliably verifying the identity of a subject (a user, computer, or service).
* **Goal:** Establish that the subject attempting access is the same one who originally registered.
* **Distinction:**
    * **Identification:** Claims "Who you are".
    * **Authentication:** Provides proof that the claim is valid.
* **Closed World Assumption:** In security, we often presume that what is not known to be true is false (default deny).

### The Authentication Lifecycle
1.  **Registration/Enrollment:** The subject establishes their identity and creates credentials (e.g., setting a [[12 Authentication based on passwords|password]], recording a fingerprint).
2.  **Credential Storage:** The system securely stores authentication data (e.g., hashed passwords, encrypted keys).
3.  **Authentication Attempt:** The subject presents credentials to the system.
4.  **Verification:** The system validates the presented credentials against the stored reference.
5.  **Access & Lifecycle Management:** Granting access, managing renewals, and revocation.

---

## 2. Authentication Factors

Authentication mechanisms rely on one or more of the following factors:

1.  **What You Know:**
    * Passwords, PINs, secret answers.
    * *Humans vs. Computers:* Humans can remember short, low-entropy strings (passwords). Computers can store high-entropy secrets (cryptographic keys).
2.  **What You Have:**
    * Smart cards, hardware tokens (RSA SecurID), mobile phones (for OTP).
3.  **Who You Are (Biometrics):**
    * **Physiological:** Fingerprint, Retina/Iris scan, Face recognition.
    * **Behavioral:** Keystroke dynamics (typing rhythm), Voice print, Handwritten signature dynamics.
    * *Issues:*
        * **False Positives/Negatives:** Biometrics are probabilistic, not deterministic.
        * **Stability:** Fingerprints can be damaged; voice changes with health.
        * **Spoofing:** Fake fingers, high-res photos, voice recordings.
4.  **Where You Are:**
    * Network IP address, GPS location.
    * *Weakness:* susceptible to spoofing (VPNs, GPS spoofing).

---

## 3. The Attacker Model

Designing secure protocols requires defining the adversary's capabilities.

### Adversary Types
* **Passive Adversary:** Can eavesdrop (sniff) on the network and collect metadata/messages but does not alter them.
* **Active Adversary:** Can inject, modify, delete, or replay messages. Can impersonate parties.
* **Insider Threat:** A legitimate user with valid credentials who abuses their privileges or whose account is compromised.

### Common Attack Vectors
* **Credential Theft:** Phishing, keyloggers, database breaches.
* **Brute Force:** Online guessing or offline cracking of stolen hashes.
* **Replay Attack:** Capturing a valid authentication message and resending it later to gain unauthorized access.
* **Man-in-the-Middle (MITM):** Intercepting and modifying traffic between two parties.
* **Relay Attack (Mafia Fraud):** Forwarding authentication challenges between an honest prover and verifier to impersonate the prover.

---

## 4. Authentication Techniques

To defend against active attacks, protocols utilize specific mechanisms:

### 1. Timestamps
* **Mechanism:** Including the current time in the message.
* **Security:** A message is only valid within a small time window (e.g., $\pm 5$ minutes).
* **Requirement:** Requires synchronized clocks between Alice and Bob.
* **Defense:** Prevents replay attacks (old messages expire).

### 2. Nonces (Number used ONCE)
* **Mechanism:** A random number generated by the verifier for a *specific* session.
* **Flow:** Verifier sends Nonce $\rightarrow$ Prover signs/encrypts Nonce $\rightarrow$ Verifier checks.
* **Defense:** Guarantees **freshness**. An attacker cannot replay an old response because the nonce changes every time.

### 3. Sequence Numbers
* **Mechanism:** Numbering messages sequentially (like TCP).
* **Defense:** Prevents message reordering and replay within a session.

---

## 5. Symmetric Key Protocols

**Scenario:** Alice and Bob share a secret symmetric key $K_{AB}$.

### A. Challenge-Response (Unilateral Authentication)
Alice wants to prove her identity to Bob.
1.  **Alice $\to$ Bob:** "I am Alice"
2.  **Bob $\to$ Alice:** $R$ (Nonce/Challenge)
3.  **Alice $\to$ Bob:** $K_{AB}\{R\}$ (Encryption of $R$)
4.  **Bob:** Decrypts to verify $R$.
* *Note:* This proves Alice knows $K_{AB}$ and is active now (freshness via $R$).

### B. Timestamp-Based
1.  **Alice $\to$ Bob:** "I am Alice", $K_{AB}\{Timestamp\}$
2.  **Bob:** Decrypts and checks if $Timestamp$ is close to current time.
* *Pros:* Single message (efficient).
* *Cons:* Requires clock synchronization.

### C. Mutual Authentication & Protocol Attacks

#### 1. The Relay Attack
An attacker (Trudy) sits between honest Alice and Bob.
1.  **Trudy $\to$ Bob:** "I am Alice"
2.  **Bob $\to$ Trudy:** $R$ (Challenge)
3.  **Trudy $\to$ Alice:** "I am Bob" (or sends a challenge)
4.  **Trudy forwards $R$ to Alice.**
5.  **Alice computes $K_{AB}\{R\}$ and sends it.**
6.  **Trudy forwards $K_{AB}\{R\}$ to Bob.**
* **Result:** Bob believes Trudy is Alice.
* **Defense:** Channel binding, distance bounding (checking round-trip time).

#### 2. The Reflection Attack
If the *same* protocol and key are used for authentication in both directions, an attacker can trick a server into answering its own challenge.
* **Scenario:** Trudy wants to impersonate Alice to Bob.
1.  **Trudy $\to$ Bob:** "I am Alice".
2.  **Bob $\to$ Trudy:** $R_1$ (Challenge).
3.  **Trudy (starts new session) $\to$ Bob:** "I am Alice".
4.  **Bob $\to$ Trudy:** $R_2$ (New Challenge).
5.  **Trudy $\to$ Bob (in Session 2):** Sends $R_1$ (Bob's challenge from Session 1) as *her* challenge.
6.  **Bob $\to$ Trudy (in Session 2):** $K_{AB}\{R_1\}$ (Bob provides the response!).
7.  **Trudy $\to$ Bob (in Session 1):** Sends $K_{AB}\{R_1\}$.
* **Result:** Bob authenticates Trudy.
* **Defense:** Use different keys for each direction ($K_{AB}$ vs $K_{BA}$) or different nonce formats (e.g., Initiator uses even numbers, Responder uses odd).

---

## 6. Trusted Third Party (Key Distribution Center)

In a network of $N$ users, managing $N(N-1)/2$ keys is impossible.
* **Solution:** A **Key Distribution Center (KDC)**.
* **Setup:** Every user shares a master key *only* with the KDC ($K_{AC}$, $K_{BC}$).
* **Goal:** The KDC generates a temporary **Session Key ($K_S$)** for Alice and Bob to communicate.

### The Needham-Schroeder Protocol
A foundational protocol for mutual authentication and key exchange.

**The Protocol Flow:**
1.  **Alice $\to$ KDC:** $A, B, N_A$
    * "I want to talk to Bob". $N_A$ is a nonce to ensure the KDC's response is fresh.
2.  **KDC $\to$ Alice:** $K_{AC}\{ N_A, B, K_S, \text{Ticket}_B \}$
    * The KDC encrypts everything with Alice's key.
    * It includes the Session Key $K_S$.
    * **Ticket$_B$:** $K_{BC}\{ K_S, A \}$. This is an encrypted package meant for Bob. Alice cannot read it, only forward it.
3.  **Alice $\to$ Bob:** $\text{Ticket}_B$
    * Alice forwards the ticket. Bob decrypts it with $K_{BC}$ to get $K_S$ and see it implies a session with $A$.
4.  **Bob $\to$ Alice:** $K_S\{ N_B \}$
    * Bob sends a nonce encrypted with the session key to verify Alice has it.
5.  **Alice $\to$ Bob:** $K_S\{ N_B - 1 \}$
    * Alice modifies the nonce and encrypts it back to prove she is live (and not just replaying).

### Vulnerability: The Denning-Sacco Attack
Needham-Schroeder is vulnerable if an old Session Key $K_S$ is compromised.
* **Scenario:** Trudy steals an old session key $K_{old}$ and a captured Ticket ($K_{BC}\{K_{old}, A\}$).
* **Attack:** Trudy sends the old Ticket to Bob.
* **Bob:** Decrypts ticket, accepts $K_{old}$ as valid.
* **Trudy:** Can now authenticate as Alice because she knows $K_{old}$ and can answer Bob's challenge ($K_{old}\{N_B\}$).
* **Fix:** Use timestamps in the Ticket (like **Kerberos** does) to limit its validity window.